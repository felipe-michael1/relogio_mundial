{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "fb87bd89-4503-4b44-9281-5c73cbf2789d",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Importando a biblioteca tkinter para criação\n",
    "        # de interfaces gráficas.\n",
    "import tkinter as tk\n",
    "\n",
    "# Importa a classe StringVar, usada para armazenar \n",
    "        # strings em aplicações Tkinter.\n",
    "from tkinter import StringVar\n",
    "\n",
    "# Importa a classe datetime do módulo datetime \n",
    "        # para trabalhar com datas e horas.\n",
    "from datetime import datetime\n",
    "\n",
    "# Importa a biblioteca pytz, que permite \n",
    "        # trabalhar com fusos horários.\n",
    "import pytz\n",
    "\n",
    "# Define a classe RelogioMundialApp, que criará o \n",
    "        # aplicativo do relógio mundial.\n",
    "class RelogioMundialApp:\n",
    "    \n",
    "    # Método construtor, chamado automaticamente ao \n",
    "            # criar uma instância da classe.\n",
    "    def __init__(self, janela):\n",
    "        \n",
    "        # Atribui o objeto tk.Tk() recebido ao atributo self.janela. \n",
    "                # Este objeto representa a janela principal do aplicativo.\n",
    "        self.janela = janela\n",
    "        \n",
    "        # Configura o título da janela principal.\n",
    "        self.janela.title(\"Relógio Mundial\")\n",
    "        \n",
    "        # Define as dimensões da janela principal (900 pixels de \n",
    "                # largura por 500 pixels de altura).\n",
    "        self.janela.geometry(\"900x500\")\n",
    "        \n",
    "        # Configura a cor de fundo da janela principal \n",
    "                # para um tom escuro de azul.\n",
    "        self.janela.configure(bg=\"#1E2A38\")  # Cor de fundo escura\n",
    "\n",
    "\n",
    "        # Dicionário que armazena os fusos horários e \n",
    "                # seus respectivos identificadores.\n",
    "        # Cada cidade é mapeada ao seu identificador de \n",
    "                # fuso horário correspondente.\n",
    "        self.fusos_horarios = {\n",
    "            'UTC': 'Etc/UTC',\n",
    "            'Nova Iorque': 'America/New_York',\n",
    "            'São Paulo': 'America/Sao_Paulo',\n",
    "            'Londres': 'Europe/London',\n",
    "            'Paris': 'Europe/Paris',\n",
    "            'Tóquio': 'Asia/Tokyo',\n",
    "            'Sidney': 'Australia/Sydney'\n",
    "        }\n",
    "\n",
    "\n",
    "        # Definição de variáveis para armazenamento dos \n",
    "                # dados de tempo e data.\n",
    "        # Variáveis do tipo StringVar são usadas em interfaces \n",
    "                # gráficas Tkinter para armazenar strings de uma \n",
    "                # maneira que o Tkinter possa monitorar \n",
    "                # automaticamente por mudanças.\n",
    "        # Isso é útil porque permite que a interface gráfica \n",
    "                # atualize automaticamente quando os valores \n",
    "                # dessas variáveis mudam.\n",
    "        # Aqui, são criados dois dicionários usando \n",
    "                # dictionary comprehensions.\n",
    "        \n",
    "        # Dicionário self.relogio_vars armazena as variáveis de \n",
    "                # tempo para cada fuso horário.\n",
    "        # Cada chave é o nome de uma cidade e cada valor é uma \n",
    "                # instância de StringVar, que irá armazenar o \n",
    "                # horário atual para aquele fuso horário.\n",
    "        self.relogio_vars = {nome: StringVar() for nome in self.fusos_horarios.keys()}\n",
    "        \n",
    "        # Dicionário self.data_vars armazena as variáveis de \n",
    "                # data para cada fuso horário.\n",
    "        # Similarmente ao dicionário de relógio_vars, cada \n",
    "                # chave é o nome de uma cidade e cada valor é uma \n",
    "                # instância de StringVar, que irá armazenar a \n",
    "                # data atual para aquele fuso horário.\n",
    "        self.data_vars = {nome: StringVar() for nome in self.fusos_horarios.keys()}\n",
    "        \n",
    "        # Configuração do layout da interface gráfica.\n",
    "        # Chama o método self.configurar_layout() que \n",
    "                # está definido na classe.\n",
    "        # Este método é responsável por organizar visualmente os \n",
    "                # componentes da interface, como labels, botões, etc.\n",
    "        # Configura todos os elementos gráficos que serão \n",
    "                # mostrados ao usuário.\n",
    "        self.configurar_layout()\n",
    "        \n",
    "        # Inicialização do método que atualiza o relógio.\n",
    "        # Chama o método self.atualizar_relogio() que também \n",
    "                # está definido na classe.\n",
    "        # Este método é crucial porque é responsável por \n",
    "                # manter o relógio atualizado.\n",
    "        # Ele faz isso ao redefinir continuamente os valores \n",
    "                # de self.relogio_vars e self.data_vars com os \n",
    "                # tempos e datas corretos a cada segundo.\n",
    "        # O método utiliza a função 'after' do Tkinter para se \n",
    "                # chamar repetidamente a cada 1000 milissegundos \n",
    "                # (ou seja, a cada segundo).\n",
    "        self.atualizar_relogio()\n",
    "\n",
    "\n",
    "    # Definição do método configurar_layout dentro da \n",
    "            # classe RelogioMundialApp.\n",
    "    # Este método é responsável por configurar e organizar \n",
    "            # visualmente todos os componentes da interface \n",
    "            # gráfica do usuário (GUI).\n",
    "    def configurar_layout(self):\n",
    "        \n",
    "        # Dicionários que definem os estilos para os \n",
    "                # rótulos da interface.\n",
    "        # 'estilo_rotulo' define o estilo padrão para os \n",
    "                # rótulos com fonte Arial, tamanho 14, negrito, \n",
    "                # fundo escuro (#1E2A38) e texto branco (#FFFFFF).\n",
    "        estilo_rotulo = {'font': (\"Arial\", 14, 'bold'), 'bg': \"#1E2A38\", 'fg': \"#FFFFFF\"}\n",
    "        \n",
    "        # 'estilo_info' é semelhante ao 'estilo_rotulo', mas com a \n",
    "                # cor do texto em azul claro (#B0BEC5), usado para \n",
    "                # informações menos importantes ou detalhadas.\n",
    "        estilo_info = {'font': (\"Arial\", 14), 'bg': \"#1E2A38\", 'fg': \"#B0BEC5\"}\n",
    "        \n",
    "        # 'estilo_hora' é usado especificamente para exibir \n",
    "                # horas, destacando-as com a cor azul (#00C1D2), \n",
    "                # indicativo de sua importância.\n",
    "        estilo_hora = {'font': (\"Arial\", 14, 'bold'), 'bg': \"#1E2A38\", 'fg': \"#00C1D2\"}\n",
    "        \n",
    "        # Criação de um widget Label (rótulo) que serve como \n",
    "                # título da aplicação.\n",
    "        # 'self.titulo' armazena o widget, que exibe o \n",
    "                # texto \"Relógio Mundial\".\n",
    "        # O título usa a fonte Arial tamanho 18 em negrito, com o \n",
    "                # mesmo esquema de cores do fundo e texto \n",
    "                # definido em 'estilo_rotulo'.\n",
    "        self.titulo = tk.Label(self.janela, \n",
    "                               text=\"Relógio Mundial\", \n",
    "                               font=(\"Arial\", 18, 'bold'), \n",
    "                               bg=\"#1E2A38\", \n",
    "                               fg=\"#FFFFFF\")\n",
    "        \n",
    "        # O método 'pack' é usado para adicionar o \n",
    "                # widget de título à janela.\n",
    "        # 'pady=10' adiciona um espaçamento vertical de 10 \n",
    "                # pixels acima e abaixo do título para separá-lo \n",
    "                # visualmente dos outros componentes da interface.\n",
    "        self.titulo.pack(pady=10)\n",
    "    \n",
    "        # Criação de um Frame (quadro), que é um \n",
    "                # container para outros widgets.\n",
    "        # 'frame_relogio' é usado para agrupar e organizar \n",
    "                # visualmente os componentes relacionados ao \n",
    "                # relógio, como os rótulos para cada fuso horário.\n",
    "        # O Frame usa o mesmo esquema de cores de fundo \n",
    "                # definido para os rótulos.\n",
    "        frame_relogio = tk.Frame(self.janela, bg=\"#1E2A38\")\n",
    "        \n",
    "        # O método 'pack' adiciona 'frame_relogio' à janela principal.\n",
    "        # 'pady=20' proporciona um espaçamento vertical \n",
    "                # de 20 pixels acima e abaixo do frame para \n",
    "                # evitar que os elementos fiquem visualmente amontoados.\n",
    "        frame_relogio.pack(pady=20)\n",
    "\n",
    "\n",
    "        # Criação de rótulos para cada fuso horário especificado \n",
    "                # no dicionário self.fusos_horarios.\n",
    "        # Um loop 'for' é usado para iterar sobre os itens do \n",
    "                # dicionário self.fusos_horarios, que contém os \n",
    "                # nomes das cidades e seus respectivos fusos.\n",
    "        for i, (cidade, _) in enumerate(self.fusos_horarios.items()):\n",
    "            \n",
    "            # Cria um novo Frame para cada cidade dentro do \n",
    "                    # frame_relogio. Este frame contém o nome da \n",
    "                    # cidade, a hora e a data.\n",
    "            # 'bg=\"#1E2A38\"' define a cor de fundo do frame \n",
    "                    # para um azul escuro.\n",
    "            # O método grid é usado para posicionar cada frame \n",
    "                    # em uma nova linha (row=i) e na primeira \n",
    "                    # coluna (column=0) dentro do frame_relogio.\n",
    "            # 'padx=20' e 'pady=5' adicionam espaçamento horizontal \n",
    "                    # de 20 pixels e vertical de 5 pixels ao redor do frame.\n",
    "            # 'sticky=tk.W' alinha o frame à esquerda (West) dentro da grid.\n",
    "            frame = tk.Frame(frame_relogio, bg=\"#1E2A38\")\n",
    "            frame.grid(row=i, column=0, padx=20, pady=5, sticky=tk.W)\n",
    "            \n",
    "            # Criação do Label para o nome da cidade. 'text=cidade' \n",
    "                    # usa o nome da cidade do dicionário como texto do label.\n",
    "            # '**estilo_rotulo' aplica o estilo definido anteriormente \n",
    "                    # para os rótulos, incluindo fonte, cor de fundo e \n",
    "                    # cor de texto.\n",
    "            # Este label é colocado na primeira coluna (column=0) \n",
    "                    # do frame e alinhado à esquerda.\n",
    "            # 'padx=10' e 'pady=5' adicionam um espaçamento \n",
    "                    # interno ao redor do label.\n",
    "            label_nome = tk.Label(frame, text=cidade, **estilo_rotulo)\n",
    "            label_nome.grid(row=0, column=0, padx=10, pady=5, sticky=tk.W)\n",
    "            \n",
    "            # Criação do Label para a hora. 'textvariable=self.relogio_vars[cidade]' \n",
    "                    # vincula este label a uma variável StringVar que \n",
    "                    # contém a hora atualizada do fuso horário.\n",
    "            # '**estilo_hora' aplica um estilo visual específico \n",
    "                    # para a exibição das horas.\n",
    "            # Este label é colocado na segunda coluna (column=1) \n",
    "                    # do frame e alinhado à esquerda.\n",
    "            label_hora = tk.Label(frame, textvariable=self.relogio_vars[cidade], **estilo_hora)\n",
    "            label_hora.grid(row=0, column=1, padx=10, pady=5, sticky=tk.W)\n",
    "            \n",
    "            # Criação do Label para a data. 'textvariable=self.data_vars[cidade]' \n",
    "                    # vincula este label a uma variável StringVar que \n",
    "                    # contém a data atualizada.\n",
    "            # '**estilo_info' aplica um estilo visual que é um pouco \n",
    "                    # menos proeminente que o estilo_hora, indicado para \n",
    "                    # informações adicionais como a data.\n",
    "            # Este label é colocado na terceira coluna (column=2) do \n",
    "                    # frame e alinhado à esquerda.\n",
    "            label_data = tk.Label(frame, textvariable=self.data_vars[cidade], **estilo_info)\n",
    "            label_data.grid(row=0, column=2, padx=10, pady=5, sticky=tk.W)\n",
    "\n",
    "\n",
    "    # Definição do método 'atualizar_relogio' dentro da \n",
    "            # classe 'RelogioMundialApp'.\n",
    "    def atualizar_relogio(self):\n",
    "        \n",
    "        # Descrição do método: atualiza o horário exibido para \n",
    "                # cada cidade listada nos fusos horários e agenda a \n",
    "                # si mesmo para rodar novamente a cada segundo.\n",
    "        \"\"\"Atualiza o relógio para cada fuso horário e agenda uma atualização a cada segundo.\"\"\"\n",
    "        \n",
    "        # Laço 'for' que percorre cada par de chave-valor no \n",
    "                # dicionário 'self.fusos_horarios'.\n",
    "        # 'cidade' é a chave (nome da cidade) e 'fuso' é o \n",
    "                # valor (identificador do fuso horário).\n",
    "        for cidade, fuso in self.fusos_horarios.items():\n",
    "            \n",
    "            # Obtém o objeto de fuso horário correspondente ao \n",
    "                    # identificador do fuso usando a biblioteca 'pytz'.\n",
    "            timezone = pytz.timezone(fuso)\n",
    "            \n",
    "            # Obtém a data e hora atuais para o fuso horário \n",
    "                    # especificado.\n",
    "            agora = datetime.now(timezone)\n",
    "            \n",
    "            # Formata a hora atual no formato de \n",
    "                    # hora: minuto: segundo (HH:MM:SS).\n",
    "            hora_atual = agora.strftime('%H:%M:%S')\n",
    "            \n",
    "            # Formata a data atual no formato 'dia da semana, dia \n",
    "                    # do mês de mês de ano'.\n",
    "            data_atual = agora.strftime('%A, %d de %B de %Y')  # Dia da semana, dia do mês e ano em português\n",
    "            \n",
    "            # Chama o método 'traduzir_data' para converter os \n",
    "                    # nomes dos dias da semana e meses para o português.\n",
    "            data_atual = self.traduzir_data(data_atual)\n",
    "            \n",
    "            # Atualiza a variável StringVar correspondente ao \n",
    "                    # horário da cidade no dicionário 'self.relogio_vars'.\n",
    "            self.relogio_vars[cidade].set(hora_atual)\n",
    "            \n",
    "            # Atualiza a variável StringVar correspondente à data da \n",
    "                    # cidade no dicionário 'self.data_vars'.\n",
    "            self.data_vars[cidade].set(data_atual)\n",
    "        \n",
    "        # Agenda a execução deste mesmo método ('self.atualizar_relogio') \n",
    "                # para daqui a 1000 milissegundos (1 segundo).\n",
    "        # Isso cria um loop que faz com que o relógio seja atualizado continuamente.\n",
    "        # Atualiza o relógio a cada 1000 milissegundos (1 segundo)\n",
    "        self.janela.after(1000, self.atualizar_relogio)\n",
    "\n",
    "\n",
    "    # Definição do método 'traduzir_data' dentro da classe 'RelogioMundialApp'.\n",
    "    # O objetivo deste método é traduzir os nomes dos dias da semana e \n",
    "                # dos meses do inglês para o português.\n",
    "    def traduzir_data(self, data):\n",
    "        \n",
    "        # Descrição do propósito do método. Este comentário explica que o \n",
    "                # método modifica a string de data para substituir nomes \n",
    "                # em inglês por equivalentes em português.\n",
    "        \"\"\"Traduz o dia da semana e o mês para português.\"\"\"\n",
    "    \n",
    "        # Dicionário contendo as traduções dos dias da semana e dos \n",
    "                # meses do ano do inglês para o português.\n",
    "        # As chaves do dicionário são os termos em inglês e os valores \n",
    "                # são os equivalentes em português.\n",
    "        traducoes = {\n",
    "            'Monday': 'Segunda-feira',\n",
    "            'Tuesday': 'Terça-feira',\n",
    "            'Wednesday': 'Quarta-feira',\n",
    "            'Thursday': 'Quinta-feira',\n",
    "            'Friday': 'Sexta-feira',\n",
    "            'Saturday': 'Sábado',\n",
    "            'Sunday': 'Domingo',\n",
    "            'January': 'Janeiro',\n",
    "            'February': 'Fevereiro',\n",
    "            'March': 'Março',\n",
    "            'April': 'Abril',\n",
    "            'May': 'Maio',\n",
    "            'June': 'Junho',\n",
    "            'July': 'Julho',\n",
    "            'August': 'Agosto',\n",
    "            'September': 'Setembro',\n",
    "            'October': 'Outubro',\n",
    "            'November': 'Novembro',\n",
    "            'December': 'Dezembro'\n",
    "        }\n",
    "    \n",
    "        # Laço de repetição que percorre cada par de chave-valor no \n",
    "                # dicionário 'traducoes'.\n",
    "        # 'ingles' representa a chave (termo em inglês) e 'portugues' \n",
    "                # representa o valor (termo em português).\n",
    "        for ingles, portugues in traducoes.items():\n",
    "            \n",
    "            # O método 'replace' é chamado sobre a string 'data'.\n",
    "            # Ele substitui todas as ocorrências do termo em inglês (chave) \n",
    "                    # pelo termo em português (valor) dentro da string.\n",
    "            data = data.replace(ingles, portugues)\n",
    "    \n",
    "        # O método retorna a string 'data' após todas as substituições \n",
    "                # terem sido feitas.\n",
    "        return data\n",
    "\n",
    "\n",
    "\n",
    "# Esta condição verifica se o script está sendo executado \n",
    "        # como o programa principal.\n",
    "# '__name__' é uma variável especial do Python que é definida \n",
    "        # como '__main__' quando o script é executado diretamente.\n",
    "# Isso não acontece quando o script é importado como um \n",
    "        # módulo em outro script.\n",
    "if __name__ == \"__main__\":\n",
    "    \n",
    "    # Criação da janela principal da aplicação utilizando a \n",
    "            # biblioteca tkinter.\n",
    "    # 'tk.Tk()' inicializa a janela principal do Tkinter, que \n",
    "            # servirá como a janela raiz da aplicação.\n",
    "    janela_principal = tk.Tk()\n",
    "    \n",
    "    # Criação de uma instância da classe 'RelogioMundialApp'.\n",
    "    # 'app_relogio_mundial' é o objeto que representa nossa aplicação. \n",
    "    # O objeto recebe 'janela_principal', que é a janela raiz, \n",
    "            # como parâmetro para a inicialização.\n",
    "    app_relogio_mundial = RelogioMundialApp(janela_principal)\n",
    "    \n",
    "    # Chamada do método 'mainloop()' sobre o objeto 'janela_principal'.\n",
    "    # 'mainloop()' é um método do Tkinter que inicia o loop de \n",
    "            # eventos da interface gráfica.\n",
    "    # Este loop espera por eventos, como cliques do mouse e \n",
    "            # entradas do teclado, e os processa enquanto a \n",
    "            # aplicação estiver rodando.\n",
    "    # É essencial para a janela permanecer aberta e responsiva.\n",
    "    janela_principal.mainloop()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c1ae74f9-3d08-421b-b3fc-465d17ca8785",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
